{
    "contents" : "#' @title Is a numeric value an integer? \n#' @description \n#' Test if a numeric object (or integer) contains an integer. \\code{is.numeric} only tests the class of the object such that \n#' \\code{is.numeric(1)} returns \\code{FALSE}.\n#' @param x the object to test.\n#' @return A boolean\n#' @seealso \\code{\\link{is.integer}}\n#' @export\ncontains.integer<-function(x){\n  return(x%%1==0);\n}\n\n#' @title Check if the object is categorical (that is not numeric)\n#' @description \n#' Test if an object belongs to class factor, character or logical. These three types are defined as categorical.\n#' @param x the object to test.\n#' @return A boolean\n#' @seealso \\code{\\link{contains.integer}}\n#' @export\nis.categorical<-function(x){\n  return(inherits(x,c(\"factor\",\"character\",\"logical\")));\n}\n\n#' @title Coerce to the numeric value contained in the object \n#' @param x the object to coerce to numeric.\n#' @return A numeric vector.\n#' @details\n#' This function is equivalent to \\code{as.numeric} except for factor where it returns the contained numeric value, not the order\n#' of the levels.\n#' @export\nfactor2numeric <- function(x){\n  return(as.numeric(as.character(x)));\n}\n\n#' @title Coerce a data frame to the list of its row\n#' @param data the data frame to coerce\n#' @return A list of all the rows (data frame themselves) of \\code{data}.\n#' @export\n#' @examples\n#' \\donttest{\n#' rows.as.list(mtcars)\n#' }\nrows.as.list=function(data){\n  alply(data,1,identity)\n}\n\n#' @title Find Interval Numbers or Indices\n#' @description \n#' Given a vector of non-decreasing breakpoints in \\code{vec}, find the interval containing each element of \\code{x}; i.e., if \n#' \\code{i <- findInterval_right.closed(x,v)}, for each index \\code{j} in \\code{x} \n#' \\eqn{v_{i_j} < x_j \\le v_{i_j + 1}}{v[i[j]] < x[j] \\le v[i[j] + 1]} where \\eqn{v_0 := -\\infty}{v[0] := - Inf}, \n#' \\eqn{v_{N+1} := +\\infty}{v[N+1] := + Inf}, and \\code{N <- length(v)}.\n#' At the two boundaries, the returned index may differ by 1, depending on the optional arguments \\code{leftmost.closed} and \\code{all.inside}\n#' @param x numeric.\n#' @param vec numeric, sorted (weakly) increasingly, of length \\code{N}, say.\n#' @param leftmost.closed logical; if true, the leftmost interval,\\code{vec[1] .. vec[2]} is treated as \\emph{closed}, see below.\n#' @param all.inside logical; if true, the returned indices are coerced\n#' into \\code{1,\\dots,N-1}, i.e., \\code{0} is mapped to \\code{1}\n#' and \\code{N} to \\code{N-1}.\n#' @details\n#'  The function \\code{findInterval_right.closed} finds the index of one vector \\code{x} in \n#'  another, \\code{vec}, where the latter must be non-decreasing.  Where\n#'  this is trivial, equivalent to \\code{apply( outer(x, vec, \">\"), 1, sum)},\n#'  \n#'  When \\code{leftmost.closed = TRUE}, the result for \\code{x[j] = vec[1]}\n#'  (\\eqn{ = \\min vec}{ = min(vec)}), is \\code{1} as for all other\n#'  values in the first interval.\n#' @return vector of length \\code{length(x)} with values in \\code{0:N} (and\n#' \\code{NA}) where \\code{N <- length(vec)}, or values coerced to\n#' \\code{1:(N-1)} if and only if \\code{all.inside = TRUE} (equivalently coercing all \n#' x values \\emph{inside} the intervals).  Note that \\code{\\link{NA}}s are\n#' propagated from \\code{x}, and \\code{\\link{Inf}} values are allowed in\n#' both \\code{x} and \\code{vec}.\n#' @seealso \\code{\\link{findInterval}}\n#' @export\nfindInterval_right.closed<-function(x, vec, leftmost.closed = FALSE, all.inside = FALSE){\n  if(any(diff(vec)<0)) stop(\"'vec' must be sorted non-decreasingly\");\n  if(all.inside){\n    vec[1]=-Inf;\n    vec[length(vec)]=Inf;\n  }\n  index=apply(outer(x,vec,\">\"),1,sum);\n  if(leftmost.closed)index[x==vec[1]]=1;\n  return(index);\n}\n\n#' @title Returns the start and end of the TRUE sequences\n#' @export\nget_intervals=function(b){\n \n  diff.b=diff(as.numeric(b));\n  index=which(diff.b!=0);\n  \n  if(length(index)==0){\n    if(b[1]){\n      return(data.frame(first=1,last=length(b)))\n    }\n    else{\n      return(NULL);\n    }\n  }\n  \n  if(diff.b[index[1]]==-1){\n    index=c(0,index);\n  }\n  if(diff.b[tail(index,1)]==1){\n    index=c(index,length(b));\n  }\n  \n  intervals=matrix(index,ncol=2,byrow=T);\n  intervals[,1]=intervals[,1]+1;\n  colnames(intervals)=c(\"first\",\"last\");\n  return(as.data.frame(intervals))\n}\n\n#' @title Unlist a column of a data frame\n#' @description This function unlists the column of a data frame (typically the column to unlist\n#' will be a list of lists or a list of vectors) while retaining information about the other\n#' columns. This function can be usefull when working with survey data with multiple answers.\n#' By unlisting the answers, one can look at occurence, repartition, etc of class of individual\n#' answers. \n#' @param data the data frame\n#' @param j the column name or index\n#' @export\n#' @examples\n#' \\donttest{\n#' survey.data=data.frame(id=1:3,believe.in.god=c(T,T,F))\n#' survey.data$why=list(\"faith\",c(\"faith\",\"fear of hell\"),\"R is my god\")\n#' unlist.column(survey.data,\"why\")\n#' }\nunlist.column=function(data,j){\n  names.data=names(data)\n  if(is.numeric(j)) j=names.data[j]\n  \n  j.unlist.name=paste0(j,\".unlist\")\n  \n  data=adply(data,1,function(df)data.frame(unlist(df[[j]])))\n  data=data[names(data)!=j]\n  names(data)[length(data)]=j\n  data=data[names.data]\n  data\n}\n\n#' @title Add to each element of a list\n#' @param L A list\n#' @param to.add element to add to the list\n#' @export\nadd.list=function(L,to.add){\n  lapply(L,function(x)x+to.add)\n}",
    "created" : 1385529980488.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "506090118",
    "id" : "3073BC66",
    "lastKnownWriteTime" : 1385530030,
    "path" : "~/R&D/R packages/Source packages/lazyr/R/general_toolbox.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}